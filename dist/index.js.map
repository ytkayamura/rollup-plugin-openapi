{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import SwaggerParser from \"@apidevtools/swagger-parser\";\nimport { type FilterPattern, createFilter } from \"@rollup/pluginutils\";\nimport type { HmrContext, Plugin } from \"vite\";\n\ninterface RollupOpenApiOptions {\n  /**\n   * A minimatch pattern, or array of patterns, which specifies the files in the build the plugin\n   * should operate on.\n   * By default all files are targeted.\n   */\n  include?: FilterPattern;\n  /**\n   * A minimatch pattern, or array of patterns, which specifies the files in the build the plugin\n   * should _ignore_.\n   * By default no files are ignored.\n   */\n  exclude?: FilterPattern;\n}\n\nconst ext = /\\.(ya?ml)|(json)$/;\n\n/**\n * A Rollup and Vite plugin which converts OpenAPI YAML files to ES6 modules.\n */\nexport default function openapi(opts: RollupOpenApiOptions = {}): Plugin {\n  const options = Object.assign({}, opts);\n  const filter = createFilter(options.include, options.exclude);\n\n  // Set of ids which were transformed by this plugin (used for HMR handling)\n  const rootIds = new Set<string>();\n\n  return {\n    name: \"openapi\",\n\n    async transform(_, id) {\n      if (!ext.test(id)) return null;\n      if (!filter(id)) return null;\n\n      // Also watch for changes in referenced YAML files\n      const refs = await SwaggerParser.resolve(id);\n      const filteredRefs = refs.paths(\"file\").filter((path) => path !== id);\n\n      for (const ref of filteredRefs) {\n        this.addWatchFile(ref);\n      }\n\n      rootIds.add(id);\n\n      const content = await SwaggerParser.bundle(id);\n\n      return {\n        code: `var data = ${JSON.stringify(\n          content,\n          null,\n          2\n        )};\\n\\nexport default data;\\n`,\n        map: null, // Swagger CLI doesn't provide a source map\n      };\n    },\n\n    /**\n     * Handle HMR in Vite\n     *\n     * This is a Vite specific workaround to [issue #7024](https://github.com/vitejs/vite/issues/7024)\n     */\n    handleHotUpdate(ctx: HmrContext) {\n      // if it is a YAML file and a referenced file, invalidate the root file\n      // and send a full-reload command\n      if (ext.test(ctx.file) && !rootIds.has(ctx.file) && !ctx.modules.length) {\n        if (process?.env?.DEBUG) {\n          console.log(\"[openapi] reload referenced file\", ctx.file);\n        }\n\n        for (const rootId of rootIds) {\n          const root = ctx.server.moduleGraph.getModuleById(rootId);\n          if (root) {\n            ctx.server.moduleGraph.invalidateModule(root);\n          }\n        }\n        ctx.server.ws.send({\n          type: \"full-reload\",\n          path: \"*\",\n        });\n      }\n      return ctx.modules;\n    },\n  };\n}\n"],"mappings":";AAAA,OAAO,mBAAmB;AAC1B,SAA6B,oBAAoB;AAkBjD,IAAM,MAAM;AAKG,SAAR,QAAyB,OAA6B,CAAC,GAAW;AACvE,QAAM,UAAU,OAAO,OAAO,CAAC,GAAG,IAAI;AACtC,QAAM,SAAS,aAAa,QAAQ,SAAS,QAAQ,OAAO;AAG5D,QAAM,UAAU,oBAAI,IAAY;AAEhC,SAAO;AAAA,IACL,MAAM;AAAA,IAEN,MAAM,UAAU,GAAG,IAAI;AACrB,UAAI,CAAC,IAAI,KAAK,EAAE,EAAG,QAAO;AAC1B,UAAI,CAAC,OAAO,EAAE,EAAG,QAAO;AAGxB,YAAM,OAAO,MAAM,cAAc,QAAQ,EAAE;AAC3C,YAAM,eAAe,KAAK,MAAM,MAAM,EAAE,OAAO,CAAC,SAAS,SAAS,EAAE;AAEpE,iBAAW,OAAO,cAAc;AAC9B,aAAK,aAAa,GAAG;AAAA,MACvB;AAEA,cAAQ,IAAI,EAAE;AAEd,YAAM,UAAU,MAAM,cAAc,OAAO,EAAE;AAE7C,aAAO;AAAA,QACL,MAAM,cAAc,KAAK;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA;AAAA;AAAA;AAAA,QACD,KAAK;AAAA;AAAA,MACP;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,gBAAgB,KAAiB;AAG/B,UAAI,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,QAAQ,IAAI,IAAI,IAAI,KAAK,CAAC,IAAI,QAAQ,QAAQ;AACvE,YAAI,SAAS,KAAK,OAAO;AACvB,kBAAQ,IAAI,oCAAoC,IAAI,IAAI;AAAA,QAC1D;AAEA,mBAAW,UAAU,SAAS;AAC5B,gBAAM,OAAO,IAAI,OAAO,YAAY,cAAc,MAAM;AACxD,cAAI,MAAM;AACR,gBAAI,OAAO,YAAY,iBAAiB,IAAI;AAAA,UAC9C;AAAA,QACF;AACA,YAAI,OAAO,GAAG,KAAK;AAAA,UACjB,MAAM;AAAA,UACN,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AACA,aAAO,IAAI;AAAA,IACb;AAAA,EACF;AACF;","names":[]}